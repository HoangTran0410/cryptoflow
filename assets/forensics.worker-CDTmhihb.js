(function(){"use strict";const E=i=>{if(i.length===0)return 0;const o=new Map;i.forEach(a=>{o.set(a,(o.get(a)||0)+1)});let r=0,l=i[0];return o.forEach((a,u)=>{a>r&&(r=a,l=u)}),l},C=(i,o)=>{const r={avgTxSize:i.avgTransactionSize||0,peakHour:i.peakActivityHour||0,roundRatio:i.roundAmountRatio||0,txCount:i.txCount||0},l={avgTxSize:o.avgTransactionSize||0,peakHour:o.peakActivityHour||0,roundRatio:o.roundAmountRatio||0,txCount:o.txCount||0},a=Math.max(r.avgTxSize,l.avgTxSize)||1,u=Math.max(r.txCount,l.txCount)||1,m=[r.avgTxSize/a,r.peakHour/24,r.roundRatio,r.txCount/u],s=[l.avgTxSize/a,l.peakHour/24,l.roundRatio,l.txCount/u];let d=0,c=0,n=0;for(let t=0;t<m.length;t++)d+=m[t]*s[t],c+=m[t]*m[t],n+=s[t]*s[t];const e=Math.sqrt(c)*Math.sqrt(n);return e===0?0:d/e},M=i=>{const o=new Map;i.forEach(s=>{o.has(s.from)||o.set(s.from,[]),o.get(s.from).push(s.to)});const r=[],l=new Set,a=new Set,u=[],m=s=>{l.add(s),a.add(s),u.push(s);const d=o.get(s)||[];for(const c of d)if(!l.has(c))m(c);else if(a.has(c)){const n=u.indexOf(c);if(n!==-1){const e=u.slice(n);e.length>=3&&r.length<10&&r.push([...e,c])}}u.pop(),a.delete(s)};return o.forEach((s,d)=>{!l.has(d)&&r.length<10&&m(d)}),r},D=i=>{if(i.length===0)return 0;let o=0;const l=i.filter(s=>{const d=s.amount;return d>=1e3&&d%1e3===0}).length/i.length;o+=l*30;const a=[...i].sort((s,d)=>s.date.getTime()-d.date.getTime());let u=0;for(let s=1;s<a.length;s++)a[s].date.getTime()-a[s-1].date.getTime()<3e5&&u++;a.length>1&&(o+=u/(a.length-1)*30);const m=Math.min(i.length*3,20);if(o+=m,i.length>1){const s=i.map(t=>t.amount),d=s.reduce((t,f)=>t+f,0)/s.length,c=s.reduce((t,f)=>t+Math.pow(f-d,2),0)/s.length,n=Math.sqrt(c),e=d>0?n/d:1;e<.1?o+=20:e<.3&&(o+=10)}return Math.min(o,100)},R=(i,o)=>{const r=i.filter(a=>a.from===o).sort((a,u)=>a.date.getTime()-u.date.getTime());if(r.length<2)return 0;const l=[];for(let a=1;a<r.length;a++)l.push(r[a].date.getTime()-r[a-1].date.getTime());return l.reduce((a,u)=>a+u,0)/l.length},k=i=>{const o=new Map;i.forEach(l=>{const a=Math.round(l.amount);o.set(a,(o.get(a)||0)+1)});const r=Array.from(o.entries()).sort((l,a)=>a[1]-l[1]).slice(0,10);return new Map(r)},P=i=>{const o=[];i.roundAmountRatio>.5&&o.push("frequent round-amount transactions");const r=i.peakActivityHour;return r>=0&&r<6?o.push("late-night activity"):r>=9&&r<17&&o.push("business-hours activity"),i.avgTransactionSize>1e4?o.push("high-value transactions"):i.avgTransactionSize<100&&o.push("micro-transactions"),i.txCount>100&&o.push("high transaction volume"),o.length>0?o.join(", "):"standard transaction behavior"},b=(i,o)=>{const r=performance.now(),l=new Map,a=new Map;i.forEach(c=>{l.has(c.from)||l.set(c.from,[]),a.has(c.to)||a.set(c.to,[]),l.get(c.from).push(c),a.get(c.to).push(c)});const u=new Map,m=[],s=new Set,d=[];for(d.push({address:o.startAddress,depth:0}),s.add(o.startAddress),u.set(o.startAddress,{address:o.startAddress,depth:0,totalVolume:0,transactionCount:0,firstSeen:new Date,lastSeen:new Date});d.length>0;){const{address:c,depth:n}=d.shift();if(n>=o.maxDepth)continue;let e=[];o.direction==="inflow"?e=a.get(c)||[]:o.direction==="outflow"?e=l.get(c)||[]:e=[...l.get(c)||[],...a.get(c)||[]],e.forEach(t=>{if(o.minAmount&&t.amount<o.minAmount||o.timeWindow&&(t.date<o.timeWindow.start||t.date>o.timeWindow.end))return;const f=t.from===c?t.to:t.from;if(!o.includeCycles&&s.has(f))return;u.has(f)||u.set(f,{address:f,depth:n+1,totalVolume:0,transactionCount:0,firstSeen:t.date,lastSeen:t.date});const h=u.get(f);h.totalVolume+=t.amount,h.transactionCount++,h.firstSeen=new Date(Math.min(h.firstSeen.getTime(),t.date.getTime())),h.lastSeen=new Date(Math.max(h.lastSeen.getTime(),t.date.getTime()));const g=m.find(p=>p.from===t.from&&p.to===t.to);g?(g.amount+=t.amount,g.count++,g.lastTx=new Date(Math.max(g.lastTx.getTime(),t.date.getTime()))):m.push({from:t.from,to:t.to,amount:t.amount,count:1,firstTx:t.date,lastTx:t.date}),!s.has(f)&&n+1<o.maxDepth&&(s.add(f),d.push({address:f,depth:n+1}))})}return{config:o,nodes:u,edges:m,paths:[],statistics:{totalNodes:u.size,totalEdges:m.length,maxDepth:Math.max(...Array.from(u.values()).map(c=>c.depth),0),executionTime:performance.now()-r}}},S=(i,o,r,l=10,a=100)=>{const u=performance.now(),m=new Map;i.forEach(e=>{m.has(e.from)||m.set(e.from,[]),m.get(e.from).push({tx:e,to:e.to})});const s=[],d=(e,t,f,h,g)=>{if(s.length>=a||g>l)return;if(e===r){const w=h.reduce((y,A)=>y+A.amount,0),T=h.map(y=>y.date.getTime()).sort((y,A)=>y-A),v=T.slice(1).map((y,A)=>y-T[A]);s.push({addresses:[...f,e],transactions:[...h],totalAmount:w,hops:h.length,startDate:new Date(T[0]),endDate:new Date(T[T.length-1]),avgDelay:v.length>0?v.reduce((y,A)=>y+A,0)/v.length:0,suspicionScore:D(h)});return}const p=m.get(e)||[];for(const{tx:w,to:T}of p)t.has(T)||(t.add(T),d(T,t,[...f,e],[...h,w],g+1),t.delete(T))};d(o,new Set([o]),[],[],0);const n=s.length>0?s.reduce((e,t)=>t.hops<e.hops?t:e,s[0]):null;return{source:o,target:r,paths:s,shortestPath:n,statistics:{totalPathsFound:s.length,avgPathLength:s.length>0?s.reduce((e,t)=>e+t.hops,0)/s.length:0,executionTime:performance.now()-u}}},z=(i,o,r,l=10)=>{const a=S(i,o,r,l,1e3),u=[];let m=0;a.paths.forEach(n=>{if(n.transactions.length===0)return;let e=n.transactions[0].amount;for(let t=0;t<n.transactions.length;t++){const f=n.transactions[t],h=f.from,p=i.filter(w=>w.from===h&&w.date>=f.date&&w.date<=new Date(f.date.getTime()+1440*60*1e3)).reduce((w,T)=>w+T.amount,0);p>0&&(e*=f.amount/p)}e>.01&&(u.push({path:n.addresses,amount:e,percentage:e/n.transactions[0].amount*100}),m+=e)});const d=i.filter(n=>n.to===r).reduce((n,e)=>n+e.amount,0),c=d>0?m/d*100:0;return{sourceAddress:o,targetAddress:r,totalTainted:m,taintPercentage:c,paths:u.sort((n,e)=>e.amount-n.amount).slice(0,20),hops:l}},_=i=>{const o=[],r=i.filter(n=>{const e=n.amount;return e>=1e3&&e%1e3===0});if(r.length>i.length*.3){const n=new Set;r.forEach(e=>{n.add(e.from),n.add(e.to)}),o.push({type:"round_amounts",severity:r.length>i.length*.5?"high":"medium",score:Math.min(r.length/i.length*100,100),affectedAddresses:Array.from(n),transactions:r.slice(0,100),description:`${r.length} transactions with round amounts detected`,metadata:{roundRatio:r.length/i.length,commonAmounts:Array.from(k(r).entries()).slice(0,5)}})}const l=new Map;i.forEach(n=>{l.has(n.from)||l.set(n.from,[]),l.get(n.from).push(n)});const a=[];if(l.forEach((n,e)=>{const t=n.sort((h,g)=>h.date.getTime()-g.date.getTime());let f=0;for(let h=1;h<t.length;h++)t[h].date.getTime()-t[h-1].date.getTime()<6e4&&f++;f>5&&a.push(e)}),a.length>0){const n=i.filter(e=>a.includes(e.from));o.push({type:"rapid_transfers",severity:"high",score:Math.min(a.length*10,100),affectedAddresses:a,transactions:n.slice(0,100),description:`${a.length} addresses with rapid consecutive transfers`,metadata:{addressCount:a.length,avgTimeBetween:"Less than 1 minute"}})}const u=M(i);if(u.length>0){const n=new Set(u.flat());o.push({type:"circular_flow",severity:"critical",score:90,affectedAddresses:Array.from(n),transactions:i.filter(e=>u.some(t=>t.includes(e.from)&&t.includes(e.to))).slice(0,100),description:`${u.length} circular flow pattern(s) detected`,metadata:{cycles:u.map(e=>e.join(" â†’ ")),cycleCount:u.length}})}const m=[];l.forEach((n,e)=>{const t=i.filter(p=>p.to===e).reduce((p,w)=>p+w.amount,0),f=n.reduce((p,w)=>p+w.amount,0);if(t===0||f===0)return;const h=Math.min(t,f)/Math.max(t,f),g=R(i,e);h>.9&&g<72e5&&n.length>5&&m.push(e)}),m.length>0&&o.push({type:"layering",severity:"high",score:85,affectedAddresses:m,transactions:i.filter(n=>m.includes(n.from)||m.includes(n.to)).slice(0,100),description:`${m.length} potential layering intermediary address(es)`,metadata:{intermediaryCount:m.length,avgTurnaround:"< 2 hours"}});const s=["tornado","mixer","tumbler","cash","blur","cyclone"],d=i.filter(n=>s.some(e=>n.from.toLowerCase().includes(e)||n.to.toLowerCase().includes(e)));if(d.length>0){const n=new Set;d.forEach(e=>{n.add(e.from),n.add(e.to)}),o.push({type:"mixer_usage",severity:"critical",score:95,affectedAddresses:Array.from(n),transactions:d,description:`${d.length} transaction(s) involving mixing/tumbler services`,metadata:{totalVolume:d.reduce((e,t)=>e+t.amount,0),mixerAddresses:Array.from(n).filter(e=>s.some(t=>e.toLowerCase().includes(t)))}})}const c=[];if(l.forEach((n,e)=>{if(n.length<20)return;const t=n.sort((g,p)=>g.date.getTime()-p.date.getTime()),h=(t[t.length-1].date.getTime()-t[0].date.getTime())/(1e3*60*60*24);h>0&&n.length/h>10&&c.push(e)}),c.length>0){const n=i.filter(e=>c.includes(e.from));o.push({type:"high_velocity",severity:"medium",score:70,affectedAddresses:c,transactions:n.slice(0,100),description:`${c.length} address(es) with high transaction velocity`,metadata:{addressCount:c.length,avgTxPerDay:"> 10"}})}return o.sort((n,e)=>e.score-n.score)},x=i=>{const o=new Map,r=new Set;i.forEach(s=>{r.add(s.from),r.add(s.to)}),r.forEach(s=>{const d=i.filter(h=>h.from===s),c=i.filter(h=>h.to===s),n=d.map(h=>h.amount),e=d.map(h=>h.date.getHours()),t=new Set;d.forEach(h=>t.add(h.to)),c.forEach(h=>t.add(h.from));const f=n.filter(h=>h>=1e3&&h%1e3===0);o.set(s,{avgTransactionSize:n.length>0?n.reduce((h,g)=>h+g,0)/n.length:0,peakActivityHour:e.length>0?E(e):0,primaryCounterparties:Array.from(t).slice(0,5),roundAmountRatio:n.length>0?f.length/n.length:0,txCount:d.length+c.length})});const l=new Map;let a=0;const u=new Set;r.forEach(s=>{if(u.has(s))return;const d=[s];u.add(s),r.forEach(c=>{if(u.has(c))return;C(o.get(s),o.get(c))>.7&&(d.push(c),u.add(c))}),d.length>1&&l.set(`cluster_${a++}`,d)});const m=[];return l.forEach((s,d)=>{const c=i.filter(t=>s.includes(t.from)||s.includes(t.to)),n=c.reduce((t,f)=>t+f.amount,0),e=o.get(s[0]);m.push({clusterId:d,addresses:s,commonBehavior:P(e),totalVolume:n,transactionCount:c.length,confidenceScore:.8,features:e})}),m.sort((s,d)=>d.addresses.length-s.addresses.length)};self.onmessage=i=>{const{type:o,payload:r,requestId:l}=i.data;try{let a;switch(o){case"DEEP_TRACE":a=b(r.transactions,r.config);break;case"FIND_PATHS":a=S(r.transactions,r.source,r.target,r.maxDepth,r.maxPaths);break;case"TAINT_ANALYSIS":a=z(r.transactions,r.source,r.target,r.maxHops);break;case"DETECT_PATTERNS":a=_(r.transactions);break;case"CLUSTER_ADDRESSES":a=x(r.transactions);break;default:throw new Error(`Unknown worker task: ${o}`)}const u={type:"SUCCESS",requestId:l,data:a};self.postMessage(u)}catch(a){const u={type:"ERROR",requestId:l,error:a instanceof Error?a.message:"Unknown error occurred"};self.postMessage(u)}}})();
